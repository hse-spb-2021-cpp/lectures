# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условные операторы `if`, `switch` (с `break` и fallthrough, включая проблему с инициализацией переменных)
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`

## Классы
* определение класса, конструктор, деструктор, методы
* специальные методы (пять штук), правило нуля, правило пяти
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
* массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

# Билеты
## 1. Базовый синтаксис
* Отличия и примерные границы значений встроенных типов ("на контесте"):
  * `int`, `double` (почему `0.1 + 0.2 != 0.3`), `bool`.
  * Знаковость и беззнаковость типов.
* Литералы: целочисленный и вещественный (в том числе `10'000` с C++14), символьный.
* Строковые литералы: обычный, raw string literal, экранирование (escaping).
* Склейка подряд написанных строковых литералов на этапе компиляции (`05-210903/01-preprocessor/01-literals-int-str-concat`).
* `static_cast<>`: пример избавления от переполнения при умножении `int`'ов.
* Разница между `i++` и `++i`.

* Составные операторы присваивания (compound assignment operator) вроде `*=`, `/=`.
* Expression и statement, что такое тип expression.
* Оператор `,` и его отличия от `;`.
* Синтаксис: `for` (включая объявление переменной в `init`), `while`, `if`, где expression и statement.
* Тернарный оператор, отличия от `if`.
* Range-based `for`, в том числе с использованием (константных) ссылок и `auto`, где возникают копирования.
* Порядок вычислений: https://notes.algoprog.ru/cpp/additional.html#id4
  * Внутри выражений: аргументы функции, операнды операторов.
  * При инициализации нескольких переменных.
  * При инициализации при помощи `{}`.
  * Что изменилось в C++17, почему в `a = b` важно сначала вычислить `b`, потом `a`.

## 2. Объявление объектов внутри одного файла
* Допустимые имена переменных, функций, констант, классов:
  * Нельзя начинать с цифры.
  * Где посмотреть ключевые слова.
  * Где можно и нельзя ставить `_`: https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
  * Что происходит от некорректного имени в разных случаях.
* Объявление и определение: функции, класса.
* Взаимная рекурсия для: функций, классов, методов внутри одного класса, методов между классами (`A::foo()` возвращает `B` и наоборот).
* Incomplete type: как объявить, что можно сделать с неполным типом.
* Пространства имён: глобальное, вложенное, синтаксис для объявления вложенных namespace с C++11.
  * Почему нельзя просто сделать класс со статическими членами?
* Поиск имён
  * Квалифицированный и неквалифицированный поиск, порядок обхода вложенных namespace
  * Отличие между `std::` и `::std::`
  * ADL (argument-dependent lookup) для операторов и функций
  * Hidden friends
* Обращение к вложенному namespace, к глобальному namespace.
* Shadowing переменных в рамках одной функции
* Псевдонимы типов: `typedef`, `using`.
* `using namespace`, где можно и нельзя использовать и почему, особенности `using namespace <другая-библиотека-вроде-std>`.

Тесно связано с: линковка.

## 3. Объявление переменных
* Объявление нескольких переменных, указателей, ссылок, в том числе константных.
* Создание временного объекта.
* Отличия copy initialization и direct initialization.
  * Тесно связано с: преобразования (conversions).
* Неинициализированные переменные/поля.
* `[[maybe_unused]]`
* Инициализация при помощи `{}`:
  * Для тривиальных типов.
  * Для нетривиальных типов.
  * Для массивов/векторов, в том числе вложенных.
  * Временных объектов: с указанием типа (`T{}`, `T()`) и без указания типа (`{}`).
  * Не было: точное определение агрегатных классов.
* Пример, где инициализация через `{}` и `()` компилируются и ведут себя по-разному.
* The most vexing parse (`06-211006/00-past`)
* Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
  * Использование константных ссылок.
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).
* `auto` и его модификации, как выводится тип.
* Structured binding для пар, простых структур, массивов, со ссылкой.
  * Не было: как делать для своих структур, что на самом деле происходит внутри, что происходит с временными значениями.

Тесно связно с: параметры функций.

## 4. Функции
* Параметры
  * Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)
  * Передача параметров по: значению, `&`, `const&`. Что выбрать и почему.
  * Примеры: `push_back`, `Person(string first_name)`.
  * Передача `{}` в параметры.
  * Неименованый параметр и `[[maybe_unused]]`
* Возвращаемое значение
  * Возврат по значению, ссылке, константной ссылке.
  * Возврат `{}` и взаимодействие с `auto`.
  * `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно
* Перегрузка функций:
  * Что входит в сигнатуру, что не входит (например, значение по умолчанию).
  * Синтаксис `= delete` с C++11.
  * Проблемы с разделением `nullptr`, `NULL`, `0`.
  * Не было: `noexcept`.
  * Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* Указатели на функции: синтаксис, использование.
  * Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.

## 5. Жизнь объектов
* Семантика копирования: что ожидается в C++ при переприсваивании объекта, передаче в качестве аргумента функции, возврата из функции.
  * А если не `Foo a;`, а `Foo &a = .....;`?
* Время жизни объектов (storage duration): автоматическое (automatic), ручное/динамическое (dynamic), статическое (static).
  * Синтаксис создания/удаления объекта.
  * Когда вызывается конструктор/деструктор и с какими параметрами.
* Время жизни временных объектов.
  * Когда создаётся/уничтожается временный объект ("наивный взгляд" до C++14 включительно).
  * Продление жизни временого объекта.
  * Проблема продления жизни в `std::min()`/`std::max()`.
  * Проблема продления жизни в range-based-for и цепочке вызовов `foo().bar()`.
* Локальные объекты со static storage duration (локальные статические переменные):
  * Когда создаётся/уничтожается.
  * Чем инициализируются, можно ли инициализировать параметром функции.

## 6. `unique_ptr`
* Возврат объектов:
  * Когда (не) надо писать `return std::move(foo);`
TODO

Тесно связано с: функции (как передавать параметры), жизнь объектов.

## 7. Стандартная библиотека
* Что такое `namespace std`.
* Контейнеры
  * `std::vector`, `std::string`, `std::list`, `std::map`: когда что использовать
  * Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`.
  * Особенность `operator[]` у `std::map`: элемент всегда создаётся, даже если его не было, почему.
  * Инвалидация итераторов и ссылок на элементы: когда, какие последствия.
* Итераторы
  * Конвенции с `begin()`/`end()`
  * Не было: иерархия итераторов, `reverse_iterator`.
* Алгоритмы
  * `sort`, передача своего компаратора.
  * `lower_bound`, `upper_bound`, точные инварианты.
* Ввод-вывод
  * `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
  * Какие `#include` бывают (2 шт)
  * Синтаксис ввода и вывода.
  * Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны friend-операторы и зачем.
  * Не было: манипуляторы, свои манипуляторы.

Тесно связано с: функторы, лямбда-функции, базовый синтаксис (порядок вычислений).

## 8. Указатели
* Базовый синтаксис: объявление, разыменование, взятие адреса, `->`.
  * Не было: многоуровневые указатели, aliasing.
* Реализация двусвязного списка, конструкции вроде `a.next->prev`.
* Нулевой указатель.
  * Отличия `nullptr` от `0`
  * Проверка на нулевой указатель.
  * Разменование `nullptr`.
* Ручное управление памятью: `new`, `delete`, `new[]`, `delete[]`, когда что использовать.
  * Не было: разница между `new int;` и `new int();`
  * Утечка памяти: UB ли, какие последствия, как ловить, как читать вывод sanitizer и Valgrind с примерами.

## 9. Классы
* Синтаксис.
* Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.
* Семантика копирования, особенности полей-констант/ссылок при копировании и инициализации.
* Конструктор: синтаксис, параметры, когда вызывается, делегирующие конструкторы.
  * Конструктор по умолчанию: когда генерируется и вызывается
* Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором
  * По умолчанию (тривиальных и с конструктором по умолчанию)
  * Default member initializer (C++11)
  * Member initialization list
  * Переприсваивание в конструкторе
* Приватные/публичные поля и методы
  * Кто к кому может обращаться, в том числе к другим объектам (а не только `this`)
  * Паттерн: геттеры и сеттеры для поддержания инвариантов, пример с отсутствием/наличием инвариантов
  * Не было: `protected`, наследование.
* Отличия `struct`/`class`.
* Вложенные классы.
* Агрегатная инициализация простых классов через `{}`
  * В том числе если члены тоже инициализируются через `{}`.
  * Что если указать не все члены.
  * Не было: строгое определение "простого класса" и его отличия между стандартами C++11, C++14, C++17, C++20.

## 10. Функции-члены (методы)
* Синтаксис объявления и вызова через `.` или `->`.
* Ключевое слово `this`
  * Где его можно не писать, зачем писать хоть где-то.
  * Чем метод отличается от свободной функции.
  * Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`.
* Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.
  * Когда возникает константный `this`.
  * Const qualifier и ограничения внутри такого метода.
  * Когда будет UB при отбрасывании const qualifier внутри метода.
  * Перегрузка по const qualifier, когда нужна.
* Ref qualifier `&` в терминах категорий значений, когда нужен.
  * Не было: ref qualifier `&&`.
* Определение методов внутри и снаружи класса, неявный `inline` и зачем.
* Удобство `auto foo() -> Foo` при определении методов снаружи класса.

## 11. Статические члены класса
* Статические поля: объявление, определение, когда что необходимо и где, обращение изнутри класса и снаружи, отличие от глобальных переменных.
  * Доступ к приватным членам в инициализаторе статического поля при определении снаружи класса
* Статические константы: объявления, определение, когда что нужно и где (для тривиальных и нетривиальных типов).
  * Не было: `constexpr`, `char[]`.
* Статические методы, отличия от свободных функций и друзей.
* Паттерн: статический метод как конструктор с именем.

Тесно связано с: линковка.

## 13. Друзья и перегрузка операторов
* Друзья-классы.
* Друзья-функции.
  * Определение внутри класса, снаружи класса.
  * Объявление до класса, внутри класса.
* Друг из другого namespace
* Виды перегружаемых операторов
  * Унарные, постфиксные/префиксные (как отличить при перегрузке?), бинарные, составное присваивание, сравнение.
  * Не было: перегрузка унарных `operator*` и `operator->`
  * `operator()`.
  * `operator[]`.
  * `operator,`, `operator&&` и `operator||` и отключение гарантий порядка вычисления аргументов
* Для каждого вида:
  * Что через кого выражать для минимизации лишних копирований и кода.
  * Конвенция для типов параметров, типа возвращаемого значения.
  * Делать оператор свободной функцией или членом, последствия для преобразований (conversions).
* Отличия `a + b`, `a.operator+(b)`, `a.operator+()`.
* Проблемы с самоприсваиванием и самомодификацией (пример простой некорректной реализации `/=` для класса рациональной дроби `Ratio`).
* Не было: `operator<=>`

## 14. Преобразования
`04-20923/03-conversions`, `07-211013/01-implicit-conversion`

* Конструкторы для преобразований и операторы преобразования.
  * Зачем два способа.
  * Что когда выбирается, когда возникают неоднозначности.
* Допустимые цепочки преобразований: не более одного пользовательского, но числовые можно.
  * Конструктор `std::string` как пользовательское преобразование, где может быть неожиданно
* Где вызывается явное преобразование (explicit), а где неявное (implicit).
  * В том числе в `static_cast<>`.
  * В том числе при работе с функциями (параметры, возвращаемое значение) и комбинировании с `{}`. Например, `return {}`.
  * В том числе для `bool`, но не других числовых типов (особенности `operator bool`).
    * Не было: safe bool idiom из C++11.
* Ключевое слово `explicit` для конструкторов и операторов преобразования, зачем нужно для конструкторов с несколькими параметрами или с нулём параметров.

## 19. Функторы и лямбды
* Реализация своих функторов.
  * Перегрузка `operator()`, когда нужен const qualifier.
  * Как использовать с `std::sort`, `std::set`, в том числе функтор без конструктора по умолчанию.
  * Использование указателя на функцию как функтор.
  * Конвенция стандартной библиотеки C++ про отсутствие состояния у функторов, `std::ref`.
* Использование функторов.
  * Передача в качестве аргумента функции.
  * Сохранение в поле класса.
* Лямбда-функции (C++11):
  * Синтаксис и expression для создания, во что превращается лямбда.
  * Возвращаемый тип: неявный вывод.
  * Независимость типов у разных лямбда-функций, почему нельзя запихнуть лямбду в `set`.
  * Неявное преобразование лямбда-функции без захватов в указатель на функцию.
  * Захваты: отсутствие, по значению, по ссылке, всех по значению, всех по ссылке, `*this` (C++17), с инициализацией (C++14).
  * Ключевое слово `mutable`.

## 20. Препроцессор
* Как пользоваться `#ifdef DEBUG`, `#define` и ключом `-DDEBUG` (в случае GCC/Clang).
* Базовый синтаксис для `#if` и `defined()`
* Определение компилятора и компилятороспецифичные `#pragma` (например, игнорирование предупреждений в GCC)
* Проблемы с аргументами макросов: приоритет операторов, повторное вычисление.
* Проблемы с макросами в качестве expression statement и трюк с `do { } while(0)`
* Проблемы с `operator,` и вызовом макросов: как добиться, чтобы `assert(true), assert(false);` работало.
* Вариадический макрос: `__VA_ARGS__` и `...`, проблемы с последней запятой (не было: решение).
* Проблемы с `assert(v == std::vector{1, 2, 3})`, `foo({1, 2})`, `foo(map<int, int>{})` и как их решать.
* Как использовать `#macro_arg`, `__FILE__`, `__LINE__` для создания своего макроса `CHECK` в тестовом фреймворке.
* Базовое использование `##` в макросах
  * Было: генерация случайных имён переменных/функций при помощи `__LINE__` (`exercises/05-211004/10-new-var`)
  * Не было: понимание, почему там надо несколько уровней макросов
* Возможность писать в макросах лишь куски корректного кода.
  * Общая идея создания фреймворка для автотестов с авторегистрацией тестов: `TEST_CASE("hi") { CHECK(1 == 2); }`.
  * Не было: точный код, макросная магия для генерации уникальных имён тестов, склейка токенов через `##`.

* Что делает `#include`, в том числе `#include <iostream>` и `#include <iosfwd>`.

## 21. Программы из нескольких файлов
* Мотивация.
* Единицы трансляции и файлы.
* Как из одного файла заиспользовать глобальную/переменную/класс/функцию из другого
* External linkage/internal linkage.
  * Слово `static` и unnamed namespace, где применять.
* Формулировка One Definition Rule, пример ошибок линковщика: multiple definition, undefined reference.
  * Перегрузки функций
* Примеры IFNDR (Ill-Formed, No Diagnostic Required):
  * Несовпадение объявлений функций: аргументы, аргументы по умолчанию, возвращаемое значение.
  * Несовпадение определений классов.
  * Потенциальные проблемы с любыми глобальными переменными (например, `write`).
* Типичный заголовочный файл.
  * Конвенция именования заголовочных файлов.
  * Include guards: зачем, как правильно, осторожно с `_`.
  * Опастность неявного включения, концепция include what you use, примеры из стандартной библиотеки вашего компилятора.
  * Запрет на реализацию функций.
  * Необходимость подключать заголовочный файл в файл с реализацией.
* Взаимная рекурсия между заголовками и forward header.
  * Incomplete type: как объявить, что можно сделать с неполным типом.
  * Пример forward hearder из стандартной библиотеки (`<iosfwd>`).
* Что обычно (не) пишут в своих заголовочных файлах (в том числе forward); `using namespace std;`.

## 22. One Definition Rule
* One Definition Rule (ODR).
  * Как можно нарушить и получить IFNDR (Ill-Formed, No Diagnostic Required) и ошибку компиляции.
  * Как можно нарушить и получить IFNDR, но не ошибку компиляции: для переменной, для функции, для класса.
* Ситуации, где нельзя гарантировать единственное определение (inline-функции, пример из фреймворка для автотестов).
* Использование `inline`-переменных/функций/методов для обхода ODR (`08-211020/03-linkage/01-inline`).
  * Требования к нескольким определениям.
* Отличия `inline` от `static`/unnamed namespace.

## 23. Static initialization order fiasco
* Глобального состояние программы: когда можно избавиться, когда необходимо.
* Создание и уничтожение объектов со статическим временем жизни.
  * У кого статическое время жизни? В том числе у некоторых локальных переменных.
  * Гарантии про порядок создания и уничтожения объектов.
* Пример static initialization order fiasco.
  * Когда существует некорректный порядок инициализации.
  * Когда не существует корректного порядка инициализации.
  * Когда происходит UB (выглядящий как утечка памяти), при этом в программе используется только `std::string`.
* Решение: идиома construct on first use.
  * Отличия решения с автоматическим временем жизни и с динамическим.

## Прочее
* Типы-тэги для пояснений к перегрузкам (`04-210923/01-functions/04-tags`)

## 1x Наследование и классы
`14-210119`, `15-210126`, `16-210202`, `17-210209`, `30-210603`

### 10. Базовое наследование
* Совместимость ссылок и указателей
* Расположение подобъектов в памяти и padding (пустое место для выравнивания)
* `public`/`private`/`protected` для методов/полей/наследования
  * Точные правила для `protected` (`12-211201/03-access-specifiers`): через какие указатели можно обращаться к `protected`-именам родителя/своим/детей; друзья (кроме доступа к protected-полям родителя через друга наследника; тут компиляторы не согласны).
* `final` для структур
* Hiding, обращение к скрытому имени, `using` для методов и конструкторов (поведение отличается), добавление перегрузок к методу родителя, изменение видимости полей/методов
* Конструкторы и наследование: отличие от наследования обычных методов
  * Вызов родительского конструктора
* Base-cast и derived-cast: неявно и через `static_cast`, когда допускается
  * Потенциальные проблемы при использовании C-style cast вместо `static_cast`
* Слайсинг и как его избежать
* Пример неполиморфного наследование при реализации двусвязного списка с фиктивным элементом
* Как вызываются невиртуальные функции

### 11. Полиморфные классы
* Полиморфные классы, виртуальные функции, `override`/`final` для методов, отличия от hiding, вызовы виртуальных функций
  * Пример реализации: таблица виртуальных функций, в том числе с наследованием
  * Чисто виртуальные функции и абстрактные классы
  * Возможность вызвать чисто виртуальную функцию
* Виртуальный деструктор: когда, зачем, что будет, если не сделать
* Вызовы виртуальных функций в конструкторах и деструкторах: обычные, с явным указанием класса через `::`
* `dynamic_cast` для указателей и ссылок (без обработки исключений), проверка `dynamic_cast` внутри `if` одновременно с определением новой переменной, требование на полиморфность класса
* Эмуляция виртуальных операторов (вроде `operator<<`, практика `14-210121`)
* Виртуальные конструкторы и паттерн "фабричная функция" (в том числе для `make_unique` и копирования)
* RTTI, оператор `typeid`, типы `type_info` и `type_index`, использование `boost::core::demangle`

### 12. Множественное наследование
`13-211208/01-mi-virtual`

* Синтаксис, пример
* Возможное представление в памяти, пример изменения адреса при `static_cast` (потому что начало подобъект теперь не всегда совпадает с началом объекта)
* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам
* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа
* Cross-cast (он же side-cast)
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding/приватное и защищённое наследование
  * В том числе при наличии одинаковых виртуальных функций в независимых базах

### 13. Виртуальное наследование
* Виртуальный базовый класс: синтаксис, пример, проблема ромба
* Порядок инициализации/уничтожения подобъектов и полей, как и где передать параметры конструктором
* Возможное представление в памяти (только для неполиморфных классов)
  * Необходимость хранения указателя в каждой виртуальной базе
* Что происходит, если один класс объявляется и виртуальным, и невиртуальным
* Взаимодействие с `dynamic_cast` при наличии виртуальных методов (работает) и их отсутствии (невозможно)
* Cross-cast (он же side-cast)
  * И delegate-to-sister
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding/приватное и защищённое наследование
  * В том числе при наличии одинаковых виртуальных функций в независимых базах

### 14. Использование наследования
* Паттерн "посетитель" (visitor, практика `15-210128`), сравнение с толпой `dynamic_cast` или добавлением виртуальных функций в базовый класс.
* Друзья и наследование + `protected`
* Проблема круга-квадрата и её решения (ограничение интерфейса на чтение/запись, убирание прямого наследования)

### 15. Разделяемые библиотеки
TODO
11-211124.02-shared-library

## 3x-4x Совместимость с языком программирования Си
`17-210209`, `19-210302`, `20-210309`, `21-210316`, `22-210323`, `23-210408`, `24-210415`

### 30. Указатели
* Арифметика указателей, one-past-the-last, array-to-pointer decay, арифметика с `void*`
  * Почему указатель нельзя трактовать как просто адрес в памяти
  * Какие указатели можно и нельзя сравнивать на `==`/`!=`, какой результат
  * Какие указатели можно и нельзя сравнивать на `<`/`<=`/`>`/`>=`, какой результат

### 32. Взаимодействие с языком Си
`08-211020/01-c-str`

* C-style-strings/ASCIIZ-строки/строки в стиле Си:
  * Определение
  * Сохранение строкового литерала в `char*`, `char[]`
  * Базовые операции: сравнение, получение длины
  * Выделение памяти/освобождение/конкатенция
  * Небезопасность функций чтения в `char*`, переполнение буфера
  * Кто владеет результатом `c_str()`

## Явно исключено
* иерархия итераторов и их виды
* `::operator new` и их перегрузка
* аллокаторы
* использование виртуального наследования для ABC (abstract base class)
* определения паттернов "Стратегия" и "Фабрика"
* `auto` и `->` в возвращаемом типе функций и лямбд
